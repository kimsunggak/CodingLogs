"""
문제
- 1.주어진 숫자가 3의 배수이면 3으로 나눈다 , 2. 2의 배수이면 2로 나눈다, 3. 1을 뺀다
- 3개의 연산이 있음
- 주어진 숫자 N이 주어졌을 때, 연산 횟수를 최소로 하여 1로 만드는 프로그램을 작성하라

접근 방법
- 3으로 나누는 연산이 많아야 연산 횟수를 최소로 만들 수 있음
- N이 3의 배수면 3으로 나누고 연산 횟수를 1 증가시킴
- N이 2의 배수이고 -1을 했을 때 3의 배수가 아니면 2로 나누고 연산 횟수를 1 증가시킴
- N이 2의 배수이고 -1을 했을 때 3의 배수라면 2로 나눌 때랑 -1을 하고 3으로 나눌 때랑 비교해서 작은 값을 선택해야 함
- N이 3의 배수도 아니고 2의 배수도 아니면 -1을 하고 연산 횟수를 1 증가시킴
문제점
- 동적 프로그래밍에 대한 이해가 
- 동적 계획법 (Dynamic Programming,DP)은 큰 문제를 작은 문제로 분할하여 해결하고
그 결과들을 저장(메모이제이션)해 중복 계산을 피함으로써 최적해를 구하는 알고리즘 기법이다.
- Top-Down 방식 (재귀 + 메모이제이션) : 문제를 재귀적으로 해결하면서, 한 번 계산한 하위 문제의 결과를 딕셔너리에 저장해두고 동일한 하위 문제가 나타나면 저장된 결과를 바로 사용하는 방식
- Bottom-up 방식 (반복문) : 가장 작은 문제부터 차례대로 해결한 후, 그 결과를 이용해 점점 큰 문제의 해답을 구하는 방식
잘못 이해한 부분 : f(n) 이 연산들을 정의한 함수라고 했을때 점화식은 f(n) = min(f(n//3) , f(n//2) , f(n-1)) + 1임
-> f(n)이 연산에 대한 함수라고 생각하다보니 f(n)의 결과가 연산 후 값이라고 생각했음
-> f(n)은 연산 횟수를 의미, 문제에서의 핵심은 연산 횟수를 최소화하는 것임
-> f(n)은 지금까지의 최소 연산 횟수 + 이번에 새로 수행한 연산(1회)
"""
import sys
memory = {} # 메모이제이션
def main():
    n = int(sys.stdin.readline().strip())
    # f(n) = min(f(n//3) , f(n//2) , f(n-1)) + 1
    def f(x):
        min_count = f(x-1) + 1
        if x in memory:
            return memory[x]
        if(x) == 1:
            return 0
        elif x % 2 == 0:
            min_count = min(f(x//2) + 1, min_count)
        elif x % 3 == 0:
            min_count = min(f(x//3) + 1, min_count)
        if x not in memory:
            memory[x] = min_count
        return min_count
if __name__ == "__main__":
    main()